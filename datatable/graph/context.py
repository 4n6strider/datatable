#!/usr/bin/env python3
# Copyright 2017 H2O.ai; Apache License Version 2.0;  -*- encoding: utf-8 -*-

# import datatable
# from datatable.utils.typechecks import typed


# Perhaps this should be moved into the 'exec' folder
class EvaluationContext(object):
    """
    Replacement for :class:`EvaluationModule`.
    """

    def __init__(self):
        self._result = None
        self._var_counter = 0
        self._functions = {}
        self._global_declarations = ""
        self._extern_declarations = ""
        self._initializer_declarations = ""
        self._global_names = set()


    def execute(self, verbose=False):
        print(self._gen_module())


    @property
    def result(self):
        return self._result


    def has_function(self, name):
        return name in self._functions

    def add_function(self, name, body):
        assert name not in self._global_names
        self._functions[name] = body
        self._global_names.add(name)

    def add_global(self, name, ctype, initvalue=None):
        assert name not in self._global_names
        if initvalue is None:
            st = "static %s %s;\n" % (ctype, name)
        else:
            st = "static %s %s = %s;\n" % (ctype, name, initvalue)
        self._global_declarations += st
        self._global_names.add(name)

    def add_extern(self, name):
        if name not in self._global_names:
            self._global_names.add(name)
            self._extern_declarations += "extern %s;\n" % _externs[name]

    def add_initializer(self, expr):
        self._initializer_declarations += "    %s;\n" % expr

    def make_variable_name(self, prefix="v"):
        self._var_counter += 1
        return prefix + str(self._var_counter)

    def get_dtvar(self, dt):
        varname = "dt" + str(dt._id)
        if varname not in self._global_names:
            ptr = dt.internal.datatable_ptr
            self.add_global(varname, "DataTable*", "NULL")
            self.add_initializer("{varname} = (DataTable*) {ptr}L"
                                 .format(varname=varname, ptr=ptr))
        return varname


    def _gen_module(self):
        out = ("/**\n"
               " * This code was generated by context.py\n"
               " **/\n\n")
        out += "// Extern declarations\n"
        out += self._extern_declarations
        out += "\n\n"
        out += "// Global variables\n"
        out += self._global_declarations
        out += "\n"
        out += "static void init(void) {\n"
        out += self._initializer_declarations
        out += "}\n"
        out += "\n\n\n"
        for fnbody in self._functions.values():
            out += fnbody
            out += "\n\n"
        return out



_externs = {
    "ISNA_F4": "inline int ISNA_F4(float)",
    "ISNA_F8": "inline int ISNA_F8(double)",
    "ISNA_I1": "inline int ISNA_I1(int8_t)",
    "ISNA_I2": "inline int ISNA_I2(int16_t)",
    "ISNA_I4": "inline int ISNA_I4(int32_t)",
    "ISNA_I8": "inline int ISNA_I8(int64_t)",
    "ISNA_U1": "inline int ISNA_U1(uint8_t)",
    "ISNA_U2": "inline int ISNA_U2(uint16_t)",
    "ISNA_U4": "inline int ISNA_U4(uint32_t)",
    "datatable_assemble":
        "DataTable* datatable_assemble(int64_t nrows, Column **cols)",
    "datatable_assemble_view":
        "DataTable* datatable_assemble_view"
        "(DataTable *src, RowMapping *rm, Column **cols)",
    "malloc":
        "void* malloc(size_t sz)",
    "pydt_from_dt":
        "DataTable_PyObject* pydt_from_dt(DataTable *dt)",
    "rowmapping_from_datacolumn":
        "RowMapping* rowmapping_from_datacolumn(Column *col, int64_t nrows)",
    "rowmapping_from_filterfn":
        "RowMapping* rowmapping_from_filterfn(FilterFn *filterfn)",
    "rowmapping_from_pyarray":
        "RowMapping* rowmapping_from_pyarray(PyObject*)",
    "rowmapping_from_pyslicelist":
        "RowMapping* rowmapping_from_pyslicelist"
        "(PyObject *starts, PyObject *counts, PyObject *steps)",
    "rowmapping_from_slice":
        "RowMapping* rowmapping_from_slice(int64_t, int64_t, int64_t)",
}
